# happens before

* 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
* 锁定规则：一个unLock操作先行发生于后面对同一个锁lock操作
* volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作
* 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C
* 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作
* 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
* 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行
* 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始


# 内存
  
  堆：java 对象区
  方法区：类结构区，class文件加载进jvm时会存在不同的数据结构中，包括常量池、域、方法数据、方法体、构造函数，Hotspot中的"永久代"
  堆和方法区是所有线程共享
  
  栈：每个线程创建时都会分配对应的栈区，包含内存变量、操作栈、方法返回值
  程序计数器：用于记录下一条要执行指令的地址和被中断地址。如果方法是native的，程序计数器的不会被定义为空
  
  栈和程序计数器是线程私有，每个线程启动时都会创建自己的栈和程序计数器
  本地方法栈：为运行native方法准备的空间
  
  OutOfMemory
  * java heap space: 堆区内存溢出，一般内存泄漏引起。
  堆大小可以通过-Xms -Xmx 调整大小
  * PermGen space：永久代溢出，即方法区，一般过多的class信息存储导致或者大量常量字符串也会导致溢出，
  方法区可以通过-XX:PermSize = 64m -XX:MaxPermSize=256m调整
  
  StackOverFlow
  * 不会抛oom，但也是常见的内存溢出，是栈溢出，一般是死循环导致或深度递归，栈大小设置较小也有会出现
  栈区可以通过-Xss来设置
  
  
  
  * 垃圾回收算法
     * 标记-清除 ：先标记，后清除算法，缺点是内存碎片较多
     * 复制算法：将内存按容量划分相等两块，每次使用其中一块。当其中一块用完，则将存活的对象复制到另外一块中，把已使用的释放。缺点：占用一半内存，使用率较低
     * 标记-整理算法：与标记清除类似，但在释放时将存活对象向一端移动然后清除除端边界以外的内存
     * 分代收集算法：目前大部分jvm 垃圾收集器都采用此类算法，根据对象的生命周期将其存放于的空间，一般分为 老年代（Tenured Generation）和新生代（Yong Generation）。
     老年代每次垃圾收集时只回收少量对象，一般使用标记整理算法，
     新声代每次收集时都有大量对象需要进行回收，一般使用复制算法
     
     * 新生代内存分配：Eden区和Survivor区，比例8:1
     
     * 分代算法中GC过程
     
     * 垃圾收集器
       * Serail/Serail Old 单线程收集器
       * ParNew 是Serail 的多线程版本
       * Parallel Scavenge 是一个新生代并行收集的收集器，目标是要达到一定的吞吐量，使用coping算法
       * Parallel Old，parallel 的老年代收集器，使用多线程和标记清除算法
       * CMS，尽量降低stw时间，采用标记-清除算法
       * G1，降低stw时间，平均stw 100ms
       * 最新的ZGC ，测试stw在1～4ms
       
      
  
  
  
  